But		r R => abre
while		r R => abre
the		r R => abre
New		r L => continua y abre
York		r L => continua
Stock		r L => continua
Exchange	l L => cierra
did		r L => continua y abre
n't		r L => continua
fall		r L => continua
apart		r L => continua
Friday		r L => continua
as		r L => continua y abre
the		r R => abre
Dow		r L => continua
Jones		r L => continua
Industrial	r L => continua
Average		l L => cierra
plunged		r L => continua y abre
190.58		r R => abre
points		l L => cierra
--		r L => continua
most		r R => abre
of		r R => abre
it		l L => cierra
in		r L => continua
the		r L => continua
final		r L => continua
hour		l L => cierra
--		l L => cierra
it		r L => continua
barely		r L => continua
managed		r R => abre
to		r L => continua
stay		r L => continua
this		r R => abre
side		l L => cierra
of		r L => continua
chaos		l L => cierra
.		l _ => cierra y devuelve


=> El r L aparece cuando se continua con el ultimo span abierto (el de arriba del stack)
=> El r R aparece cuando se abre un nuevo span (se mete en el stack)
=> El l L aparece cuando se cierra el ultimo span abierto (se le elimina del stack)

=> in my encoding lR does not appear. why?


mine	nikita
1 r R   1 r R
2 r R   2 r R
3 r R   3 r R
4 r L   4 r L
5 r L   5 r L
6 r L   6 r L
7 l L   7 l L
8 r L   8 r L
9 r L   9 r L
10 r L  10 r L
11 r L  11 r L
12 r L  12 r L
13 r L  13 r L
14 r R  14 r R
15 r L  15 r L
16 r L  16 r L
17 r L  17 r L
18 l L  18 l L
19 r L  19 r L
20 r R  20 r R

21 l R  21 l L	

22 r L  22 r L
23 r R  23 r R
24 r R  24 r R

25 l R  25 l L	

26 r L  26 r L
27 r L  27 r L
28 r L  28 r L
29 l L  29 l L
30 l L  30 l L
31 r L  31 r L
32 r L  32 r L
33 r R  33 r R
34 r L  34 r L
35 r L  35 r L
36 r R  36 r R

37 l R  37 l L

38 r L  38 r L
39 r L  39 l L
40 l L  40 l _


--> Otra opcion seria numerar los nodos en un in-order traversal (o meterlos en una lista) y luego procesarlos?

def process() -> 
	label = direction(self)
	label += direction(whoInsertedMe())

--> podriamos storear 'quien' inserto el nodo en el stack (o eliminarlo?) y procesarlo
STACK = []
[S]				=> exist top(children) then pop() and insert reverse(children)
[S* But]			=> not_exist top(children) then pop() and process()
[S*]				=> exist top(children) then pop() and insert reverse(children)
[S** SBAR]			=> exist top(children) then pop() and insert reverse(children)
[S** S while] 			=> not_exist top(children) then pop() and process()
[S** S]				=> exist top(children) then pop() and insert reverse(children)	
[S** VP NP]			=> exist top(children) then pop() and insert reverse(children)	
[S** VP NP* the]		=> not_exist top(children) then pop() and process()
[S** VP NP** New] 		=> not_exist top(children) then pop() and process()
[S** VP NP*** York]		=> not_exist top(children) then pop() and process()
[S** VP Exchange Stock]		=> not_exist top(children) then pop() and process()
[S** VP Exchange]		=> not_exist top(children) then pop() and process()
	
	
							
(...)


A ver ellos el decoding lo hacen de 'flecha en flecha'. El equivalente seria:
'G': 
	(1) mover word del buffer al stack
	(2) construir un arbol donde el hijo izquierdo es el top del stack y el hijo derecho es NONE
	
'-G':
	(1) pillar siguiente word del buffer
	(2) reemplazar el hijo NONE del elemento que esta en el top del stack por esa word
	
'1':
	(1) mover word del buffer al stack
	(2) construir un arbol donde el hijo izquierdo es el top del stack y el hijo derecho es NONE
	(3) reemplazar el hijo NONE del elemento que esta en el top del stack por ese arbol
	
	














































